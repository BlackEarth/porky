/*  porky  JavaScript productivity extension library with database access for Adobe InDesign  (c)2009 - 2015 Dipl.-Ing. (FH) Oliver Grünberg  www.porky.io  Include this file in your JSX scripts before anything else   #include ../yourPathToPorky/porky.jsx;  Then go and fill your global variables  Start porky data source access  via commandline  php porky-db-access.php  Quit porky data source access  via web browser  http://127.0.0.1:6789/cXVpdCBwb3JreQo=  via command line  Get base64 encoded string  echo 'quit porky' | openssl base64  curl 127.0.0.1:6789/cXVpdCBwb3JreQo=*/#include ../lib/json-js/json_parse.js#include ../lib/json-js/json2.js#include ../lib/base64/base64-encode-decode.js//*****************************************************************************************************************************************************************/*  global objects*/settings = {    dataSource : {        type: '',        server: '',        name: '',        username: '',        password: ''    },    sync: {        scriptFolder: '',        identifier: ''    }};/*  porky data source access*/function connectToDataSource(dataSourceQuery){  var getRequest = JSON.stringify({      "porky": {          "dataSourceType": settings.dataSource.type,          "dataSourceServer": settings.dataSource.server,          "dataSourceName": settings.dataSource.name,          "dataSourceUsername": settings.dataSource.username,          "dataSourcePassword": settings.dataSource.password,          "dataSourceQuery": dataSourceQuery        }    });  /*    {      "porky": {        "dataSourceType": "SQLite",        "dataSourceServer": "127.0.0.1",        "dataSourceName": "TestDatabase",        "dataSourceUsername": "Oliver",        "dataSourcePassword": "1234",        "dataSourceQuery": "SELECT * FROM bla"      }    }  */  var getRequestBase64 = Base64.encode(getRequest);  var reply = "";  var conn = new Socket;  conn.timeout = 600000;  if (conn.open ("127.0.0.1:6789", "UTF-8")) {    // send a HTTP GET request    var result = conn.write ("GET /" + getRequestBase64 + " HTTP/1.0\n\n");    // and read the server’s reply    reply = conn.read(99999999999);    var close = conn.close();  }else{    alert("Warning\nCannot establish porky data source access!");    exit(0);  }  if(reply.length > 0){    //decode reply from base64    reply = Base64.decode(reply);    return reply;  }}/*  porky core functions for Adobe InDesign*/function addFrame(xFrame, yFrame, wFrame, hFrame, stringOrFile){  var tempFrame = app.activeWindow.activePage.rectangles.add();  var tempXFrame = xFrame;  var tempYFrame = yFrame;  var tempWFrame = wFrame + xFrame;  var tempHFrame = hFrame + yFrame;  tempFrame.geometricBounds = [tempYFrame, tempXFrame, tempHFrame, tempWFrame];  if(typeof(stringOrFile) == "string"){    tempFrame.contentType = 1952412773;    tempFrame.getElements()[0].contents = stringOrFile;    return tempFrame.getElements()[0];  }  if(typeof(stringOrFile) == "object"){    var tempPic = new File(stringOrFile);    tempFrame.place (tempPic, false);    return tempFrame;  }}function appendToFrame(frameObject, stringOrFileOrTwoDArray){    if(typeof(stringOrFileOrTwoDArray) == "object"){      // array -> create and append table      if (stringOrFileOrTwoDArray instanceof Array){        //Höchste Anzahl benötigter Spalten herausfinden        var colMaxCount = [];        for(var i=0; i<stringOrFileOrTwoDArray.length; i++){          colMaxCount[i] = stringOrFileOrTwoDArray[i].length;        }        //Hilfsfunktion zum Zahlen sortieren        function numsort(a, b) {          return b-a;        }        //Höchster Spaltenwert        colMaxCount = colMaxCount.sort(numsort)[0];        //Erste Zeile mit 1 Zelle exemplarisch anlegen        var tempAppendedTable = frameObject.tables.add();        tempAppendedTable.columnCount = colMaxCount; //Limit: 200        tempAppendedTable.bodyRowCount = 1;        //Inhaltszeilen anlegen        for(var i=0; i<stringOrFileOrTwoDArray.length; i++){          tempAppendedTable.rows[i].contents = stringOrFileOrTwoDArray[i];          tempAppendedTable.rows.add();        }        //Letzte leere Zeile entfernen        tempAppendedTable.rows.lastItem().remove();        return tempAppendedTable;      }else{        // not an array -> file -> append/place inline file object        var tempPic = new File(stringOrFileOrTwoDArray);        // var tempAppendedPic = frameObject.parentStory.insertionPoints[-1].place (tempPic, false, {visibleBounds:["0 mm","0 mm","10 mm","10 mm"]});        var tempAppendedPic = frameObject.parentStory.insertionPoints[-1].place (tempPic, false);        // return parent container [object Rectangle] of image        return tempAppendedPic[0].parent;      }    }else if(typeof(stringOrFileOrTwoDArray) == "string"){      // string -> append string      frameObject.parentStory.insertionPoints[-1].contents = stringOrFileOrTwoDArray;      var tempAppendedText = frameObject.parentStory.characters.itemByRange(-1, -stringOrFileOrTwoDArray.length);      return tempAppendedText;    }}function tagThis(tagObject, syncScript, syncIdentifier){  //SOLL: InsertionPoint, Word, Text, Paragraph, Character, TextColumn, Story, Table, TextFrame, Rectangle, Image  //IST:     InsertionPoint, Word, Text, Paragraph, Character, TextColumn,          , Table, TextFrame, Rectangle  var porkyTagElement = "";  var tempTagName = "porky";  //Textframe  if(tagObject == "[object TextFrame]"){    var assXMLElem = tagObject.parentStory.associatedXMLElement;    if(assXMLElem == null){      //app.activeDocument.xmlElements.item(0).xmlElements.add(tempTagName, tagObject.parentStory);      assXMLElem = app.activeDocument.xmlElements.item(0).xmlElements.add(tempTagName, tagObject.parentStory);    }    if(!assXMLElem.xmlAttributes.item("syncScript").isValid){      assXMLElem.xmlAttributes.add("syncScript", syncScript);    }else{      assXMLElem.xmlAttributes.item("syncScript").value = syncScript;    }    if(!assXMLElem.xmlAttributes.item("syncIdentifier").isValid){      assXMLElem.xmlAttributes.add("syncIdentifier", syncIdentifier);    }else{      assXMLElem.xmlAttributes.item("syncIdentifier").value = syncIdentifier;    }    return assXMLElem;//XML Element zurückgeben  }  // Rectangle  if(tagObject == "[object Rectangle]"){    var assXMLElem = tagObject.associatedXMLElement;    if(assXMLElem == null){      assXMLElem = app.activeDocument.xmlElements.item(0).xmlElements.add(tempTagName, tagObject);    }    if(!assXMLElem.xmlAttributes.item("syncScript").isValid){      assXMLElem.xmlAttributes.add("syncScript", syncScript);    }else{      assXMLElem.xmlAttributes.item("syncScript").value = syncScript;    }    if(!assXMLElem.xmlAttributes.item("syncIdentifier").isValid){      assXMLElem.xmlAttributes.add("syncIdentifier", syncIdentifier);    }else{      assXMLElem.xmlAttributes.item("syncIdentifier").value = syncIdentifier;    }    return assXMLElem;//XML Element zurückgeben  }  if(tagObject == "[object Word]" || tagObject == "[object Paragraph]" || tagObject == "[object InsertionPoint]" || tagObject == "[object Character]" || tagObject == "[object Text]" || tagObject == "[object TextColumn]"){    //Bei direkter Verwendung des Objekts über eine Variable    if(tagObject.parent instanceof Array){      //[object Story] von tagObject taggen, falls nicht schon geschehen      try{        app.activeDocument.xmlElements.item(0).xmlElements.add(tempTagName, tagObject.parent[0]);      }catch(e){        // $.writeln("tagObject.parent -> cannot add xmlElements.add(): " + e);        //alert(e);      }    }    //Bei selection[0]    if(!tagObject.parent instanceof Array){      //[object Story] von tagObject taggen, falls nicht schon geschehen      try{        app.activeDocument.xmlElements.item(0).xmlElements.add(tempTagName, tagObject.parent);      }catch(e){        // $.writeln("!tagObject.parent -> cannot add xmlElements.add(): " + e);        //alert(e);      }    }    if(tagObject.parent == "[object Story]"){      try{        //alert(tagObject.contents + "\n" + tagObject.associatedXMLElements[0].xmlContent.contents);        if( tagObject == tagObject.associatedXMLElements[0].xmlContent){          tempTagName = tagObject.associatedXMLElements[0].markupTag.name;          tagObject.associatedXMLElements[0].untag();        }      }catch(e){        // $.writeln("tagObject.parent = [object Story]-> cannot associatedXMLElements[0].untag(): " + e);        //alert(e);      }      tagObject = app.activeDocument.xmlElements.item(0).xmlElements.add(tempTagName, tagObject);      tagObject.xmlAttributes.add("syncScript", syncScript);      tagObject.xmlAttributes.add("syncIdentifier", syncIdentifier);      return tagObject;//XML Element zurückgeben    }    // Text selection inside of table cell    if(tagObject.parent == "[object Cell]"){      // alert("porky\n" + tagObject.parent + '\n' +  tagObject);      try{        // alert(tagObject.parent + '\n' + tagObject.contents + "\n" + tagObject.associatedXMLElements[0].xmlContent);        if( tagObject == tagObject.associatedXMLElements[0].xmlContent){          tempTagName = tagObject.associatedXMLElements[0].markupTag.name;          tagObject.associatedXMLElements[0].untag();        }      }catch(e){        // alert(e);      }      tagObject = app.activeDocument.xmlElements.item(0).xmlElements.add(tempTagName, tagObject);      tagObject.xmlAttributes.add("syncScript", syncScript);      tagObject.xmlAttributes.add("syncIdentifier", syncIdentifier);      return tagObject;//XML Element zurückgeben    }else{      return tagObject;    }  }  // Table  if(tagObject == "[object Table]"){    try{      //alert(tagObject.contents + "\n" + tagObject.associatedXMLElement.xmlContent.contents);      if( tagObject == tagObject.associatedXMLElement.xmlContent){        tempTagName = tagObject.associatedXMLElement.markupTag.name;        tagObject.associatedXMLElement.untag();      }    }catch(e){      // $.writeln("tagObject = [object Table]-> cannot associatedXMLElement.untag(): " + e);      //alert(e);    }    tagObject = app.activeDocument.xmlElements.item(0).xmlElements.add(tempTagName, tagObject);    tagObject.xmlAttributes.add("syncScript", syncScript);    tagObject.xmlAttributes.add("syncIdentifier", syncIdentifier);    return tagObject;//XML Element zurückgeben  }  // Table cell ***  if(tagObject == "[object Cell]"){    alert('[object Cell] is not supported')  }else{    return tagObject;  }}function recursiveSyncFrame(frameObject){  var tempRes = "";  if (frameObject instanceof Array) {    //aus Array    for (var c = 0; c < frameObject.length; c++){      //Rahmen      if(frameObject[c] == "[object XMLElement]"){        tempRes = recursiveSyncXMLElement(frameObject[c]);      }      if(frameObject[c] == "[object TextFrame]" || frameObject[c] == "[object Rectangle]" || frameObject[c] == "[object Image]" || frameObject[c] == "[object Story]"){        tempRes = recursiveSyncXMLElement(frameObject[c].associatedXMLElement);      }    }  //direkt  } else {    if(frameObject == "[object XMLElement]"){      tempRes = recursiveSyncXMLElement(frameObject);    }    if(frameObject == "[object TextFrame]" || frameObject == "[object Rectangle]" || frameObject == "[object Image]" || frameObject == "[object Story]"){      tempRes = recursiveSyncXMLElement(frameObject.associatedXMLElement);    }  }  return tempRes;}function setSyncIdentifier(singleTaggedObject, syncIdentifier){    try{        if(singleTaggedObject == "[object Table]" || singleTaggedObject == "[object TextFrame]" || singleTaggedObject == "[object Rectangle]" || singleTaggedObject == "[object Image]" || singleTaggedObject == "[object Story]"){            if(singleTaggedObject.associatedXMLElement.isValid){              singleTaggedObject.associatedXMLElement.xmlAttributes.item("syncIdentifier").value = syncIdentifier;            }        }else if(singleTaggedObject == "[object Word]" || singleTaggedObject == "[object Paragraph]" || singleTaggedObject == "[object InsertionPoint]" || singleTaggedObject == "[object Character]" || singleTaggedObject == "[object Text]" || singleTaggedObject == "[object TextColumn]" || singleTaggedObject == "[object Line]"){          if(singleTaggedObject.associatedXMLElements[0].isValid){            singleTaggedObject.associatedXMLElements[0].xmlAttributes.item("syncIdentifier").value = syncIdentifier;          }        }        return singleTaggedObject;    }catch(e){      // $.writeln("setSyncIdentifier(singleTaggedObject, syncIdentifier): " + e);      alert("Error\nCan't set \"" + syncIdentifier + "\" in associatedXMLElement.xmlAttributes.item(\"syncIdentifier\").value\n\n" + e);      return false;    }}function recursiveSetSyncIdentifier(taggedObject, syncIdentifier){    try{        for(var t = 0; t < taggedObject.length; t++){            if(taggedObject[t] == "[object Table]" || taggedObject[t] == "[object TextFrame]" || taggedObject[t] == "[object Rectangle]" || taggedObject[t] == "[object Image]" || taggedObject[t] == "[object Story]"){                if(taggedObject[t].associatedXMLElement){                  var tempAssElem = taggedObject[t].associatedXMLElement;                    //taggedObject[t].associatedXMLElement.xmlAttributes.item("syncIdentifier").value = syncIdentifier;                    if(tempAssElem.markupTag.name == "porky" && tempAssElem.xmlAttributes.item("syncIdentifier").isValid){                        tempAssElem.xmlAttributes.item("syncIdentifier").value = syncIdentifier;                    }                    //sub elements                    for(var i = 0; i < tempAssElem.xmlElements.length; i++){                        if(tempAssElem.xmlElements[i].markupTag.name == "porky" && tempAssElem.xmlElements[i].xmlAttributes.item("syncIdentifier").isValid){                            tempAssElem.xmlElements[i].xmlAttributes.item("syncIdentifier").value = syncIdentifier;                        }                    }                }            }else if(taggedObject[t] == "[object Word]" || taggedObject[t] == "[object Paragraph]" || taggedObject[t] == "[object InsertionPoint]" || taggedObject[t] == "[object Character]" || taggedObject[t] == "[object Text]" || taggedObject[t] == "[object TextColumn]" || taggedObject[t] == "[object Line]"){                if(taggedObject[t].associatedXMLElements[0]){                    var tempAssElemsFirst = taggedObject[t].associatedXMLElements[0];                    //taggedObject[t].associatedXMLElements[0].xmlAttributes.item("syncIdentifier").value = syncIdentifier;                    if(tempAssElemsFirst.markupTag.name == "porky"){                        tempAssElemsFirst.xmlAttributes.item("syncIdentifier").value = syncIdentifier;                    }                    //sub elements                    for(var i = 0; i < tempAssElemsFirst.xmlElements.length; i++){                        if(tempAssElemsFirst.xmlElements[i].markupTag.name == "porky"){                            tempAssElemsFirst.xmlElements[i].xmlAttributes.item("syncIdentifier").value = syncIdentifier;                        }                    }                }            }        }        return taggedObject;    }catch(e){        // $.writeln("recursiveSetSyncIdentifier(taggedObject, syncIdentifier): " + e);        alert("Error\nCan't set \"" + syncIdentifier + "\" in associatedXMLElement.xmlAttributes.item(\"syncIdentifier\").value\n\n" + e);        return false;    }/*    if(taggedObject.associatedXMLElement.markupTag.name == "porky"){        taggedObject.associatedXMLElement.xmlAttributes.item("syncIdentifier").value = syncIdentifier;;    }    //sub elements    for(var i = 0; i < taggedObject.associatedXMLElement.xmlElements.length; i++){        if(taggedObject.associatedXMLElement.xmlElements[i].markupTag.name == "porky"){            taggedObject.associatedXMLElement.xmlElements[i].xmlAttributes.item("syncIdentifier").value = syncIdentifier;        }    }    return taggedObject;*/}function syncXMLElement(taggedXMLElement){  // if not [object XMLElement] then use the object's associatedXMLElement  if(taggedXMLElement != "[object XMLElement]"){    if(taggedXMLElement == "[object Table]" || taggedXMLElement == "[object TextFrame]" || taggedXMLElement == "[object Rectangle]" || taggedXMLElement == "[object Image]" || taggedXMLElement == "[object Story]"){      if(taggedXMLElement.associatedXMLElement.isValid){        syncXMLElement(taggedXMLElement.associatedXMLElement);       }     }    else if(taggedXMLElement == "[object Word]" || taggedXMLElement == "[object Paragraph]" || taggedXMLElement == "[object InsertionPoint]" || taggedXMLElement == "[object Character]" || taggedXMLElement == "[object Text]" || taggedXMLElement == "[object TextColumn]" || taggedXMLElement == "[object Line]"){      if(taggedXMLElement.associatedXMLElements[0].isValid){        syncXMLElement(taggedXMLElement.associatedXMLElements[0]);      }     }else{       return taggedXMLElement;    }  // if [object XMLElement] then use the object's xmlContent directly  }else{    if(taggedXMLElement != null){      // only proceed if there's more than 2 attributes      if(taggedXMLElement.xmlAttributes.length > 1){        // only proceed if at minimum the attributes syncScript and syncIdentifier are available        if(taggedXMLElement.xmlAttributes.item("syncScript").isValid && taggedXMLElement.xmlAttributes.item("syncIdentifier").isValid){          // set global object settings.sync.identifier for use in external sync scripts          settings.sync.identifier = taggedXMLElement.xmlAttributes.item("syncIdentifier").value;          // handle images          if (taggedXMLElement.xmlContent == "[object Image]" || taggedXMLElement.xmlContent == "[object EPS]" || taggedXMLElement.xmlContent == "[object PDF]" || taggedXMLElement.xmlContent == "[object PICT]" || taggedXMLElement.xmlContent == "[object WMF]"){            try{              // content syncable              taggedXMLElement.xmlContent.place (new File( $.evalFile(File(settings.sync.scriptFolder + taggedXMLElement.xmlAttributes.item("syncScript").value))), false);              return taggedXMLElement;            }catch(e){              // content not syncable or already done by external syncScript              // $.writeln("taggedXMLElement.xmlContent.place(): " + e);              return e;            }          }          // handle text          else if (taggedXMLElement.xmlContent == "[object Story]" || taggedXMLElement.xmlContent == "[object Text]" || taggedXMLElement.xmlContent == "[object Table]"){                        // [object Story] or [object Text]            // var tempLocation = taggedXMLElement.xmlContent.parentStory;            var tempLocation = taggedXMLElement.xmlContent;            // if not a table            if(tempLocation.tables.length < 1){              try{                // content syncable                taggedXMLElement.contents = $.evalFile(File(settings.sync.scriptFolder + taggedXMLElement.xmlAttributes.item("syncScript").value));                return taggedXMLElement;              }catch(e){                // content not syncable or already done by external syncScript                // $.writeln("taggedXMLElement.contents = : " + e);                return e;              }            }            // if table            else if (tempLocation.tables.length > 0){              try{                // content syncable                // [object Table]                var newTableArray = "";                var tempRowsCount = "";                var tempColsCount = "";                // get content for new table                // content type is a 2-dimensional array                newTableArray = $.evalFile(File(settings.sync.scriptFolder + taggedXMLElement.xmlAttributes.item("syncScript").value));                // first delete all existing rows but keep first                if (tempLocation.tables[0].rows.length > 1){                  tempRowsCount = tempLocation.tables[0].rows.length;                  for(var i = 0; i < tempRowsCount-1; i++){                    tempLocation.tables[0].rows.lastItem().remove();                  }                }                // then delete all columns but keep first                if (tempLocation.tables[0].columns.length>1){                  tempColsCount = tempLocation.tables[0].columns.length;                  for(var i = 0; i< tempColsCount-1; i++){                    tempLocation.tables[0].columns.lastItem().remove();                  }                }                // calculate max columns                var colMaxCount = [];                for(var i=0; i<=newTableArray.length-1; i++){                  colMaxCount[i] = newTableArray[i].length;                }                // little helper function for sorting numbers                function numsort(a, b) {                  return b-a;                }                // max columns count                colMaxCount = colMaxCount.sort(numsort)[0];                // create first row                for(var i=1; i<colMaxCount; i++){                  tempLocation.tables[0].columns.add();                }                // add content rows                for(var i=0; i<newTableArray.length; i++){                  tempLocation.tables[0].rows[i].contents = newTableArray[i];                  tempLocation.tables[0].rows.add();                }                // remove last empty row                tempLocation.tables[0].rows.lastItem().remove();                return taggedXMLElement;              }catch(e){                // content not syncable or already done by external syncScript                // $.writeln("content not syncable or already done by external syncScript : " + e);                return e;              }            }else{              return false;            }          }        }else{          return false;        }      }    }  }}function recursiveSyncXMLElement(taggedXMLElement){  if(taggedXMLElement == "[object XMLElement]"){    syncXMLElement(taggedXMLElement);    //Sub Elemente    for(var i = 0; i < taggedXMLElement.xmlElements.length; i++){      recursiveSyncXMLElement(taggedXMLElement.xmlElements[i]);    }    return taggedXMLElement;  }else{    return false;  }}function createPlaceholderImage(){  //Platzhalter Bild aus Binärstring schreiben  var placeholderImageBinaryString = (new String("\u0089PNG\r\n\x1A\n\x00\x00\x00\rIHDR\x00\x00\x00a\x00\x00\x00X\b\x02\x00\x00\x00j\x11\x0E\u0091\x00\x00\x00\x01sRGB\x00\u00AE\u00CE\x1C\u00E9\x00\x00\x00\x04gAMA\x00\x00\u00B1\u008F\x0B\u00FCa\x05\x00\x00\x00 cHRM\x00\x00z&\x00\x00\u0080\u0084\x00\x00\u00FA\x00\x00\x00\u0080\u00E8\x00\x00u0\x00\x00\u00EA`\x00\x00:\u0098\x00\x00\x17p\u009C\u00BAQ<\x00\x00\x01ZIDATx^\u00ED\u00DA\u00C1\t\u00C2@\x00E\u00C1X\u00A0\u009D\u00A5\x02{\u00B1\x18+\u0089\x01\u00EF\u00CE!\u00EC\u00EA\u00C2\x0B\u00DE|F3~A\u00C4\u00DBq\x1C[\u00C7w\u0081\u00D3\u00A8\u00E3\u00BB\u00C0\x16\x10\x052\"\u00D1\u0091QF\x16p\u00D1\u008E2\u00B2\u0080\u008B\u0089;\u00DA\u00B6\u00F3\u009B\u00D8\u00A5\u009B/gH\u0091\u0091Y3\u00CA\u00C8\x02.\u00DAQF\x16p\u00D1\u008E2\u00B2\u0080\u008Bv\u0094\u0091\x05\\\u00B4\u00A3\u008C,\u00E0\u00A2\x1Ded\x01\x17\u00ED(#\x0B\u00B8hG\x19Y\u00C0E;\u00CA\u00C8\x02.\u00DAQF\x16p\u00D1\u008E2\u00B2\u0080\u008Bv\u0094\u0091\x05\\\u00B4\u00A3\u008C,\u00E0\u00A2\x1Ded\x01\x17\u00ED(#\x0B\u00B8XgG\u00FB\u00EE\u00AB\x19S\u00ACc\u00F4|\u008E\x11\u00F0Y3\u00CA\u00C8\x02.\u00DAQF\x16p\u00B1\u00CE\u008E^/_\u00CD\u0098b\u00A2\u00D1\u00FD\u00BE\u00E2\x1F\u008FO\u00F6\u0089F\u008FGF\x1A\u00FA\u00F9a\u00B9\u00F2\x1Fv\u009D~\u00DC\u00FD\x13w4\u00EE\"\x06\u009F9#\x03g\u0094\u0091\x05\\\u00B4\u00A3\u008C,\u00E0\u00A2\x1D\u00FD\u0095\u00D1\u0095/G\u009F\u00C7\u00FE\u00E8\u0098\u00F8\u00C4\x19\u00F9=\u00CE(#\x0B\u00B8hG\x19Y\u00C0E;\u00CA\u00C8\x02.\u00DAQF\x16p\u00D1\u008E2\u00B2\u0080\u008Bv\u0094\u0091\x05\\\u00B4\u00A3\u008C,\u00E0\u00A2\x1Ded\x01\x17\u00ED(#\x0B\u00B8hG6Z\u00B6\u0098\u00F8\u009B\x7FF\u00CB\n\u00F8\u0085\u00B7\u00A3\u008C,\u00E0\u00A2\x1Ded\x01\x17\u00ED(#\x0B\u00B8hG6z\x03\u009Cs\u00D4\u00CDK\u00B4\x14\u00F2\x00\x00\x00\x00IEND\u00AEB`\u0082"));  var placeholderImageFolder = new Folder( File($.fileName).parent);  placeholderImageFolder.create();  var placeholderImage = new File( placeholderImageFolder.absoluteURI + "/placeholderImage.png" );  placeholderImage.encoding = "BINARY";  placeholderImage.open("w");  placeholderImage.write(placeholderImageBinaryString);  placeholderImage.close();  return placeholderImage;}function stringToTwoDArray(separatedString, columnSeparator, rowSeparator){  if(separatedString == "" || columnSeparator == "" || rowSeparator == ""){    return false;  }else{    var hasColumnSeparator = separatedString.indexOf(columnSeparator);    var lastChar = separatedString.substring(separatedString.length-rowSeparator.length, separatedString.length);    if(lastChar != rowSeparator){      separatedString = separatedString + rowSeparator;    }    var array1D = [];    array1D = separatedString.split(rowSeparator);    var array2D = [];    for(zaehler1D = 0; zaehler1D < array1D.length-1; zaehler1D++){      array2D[zaehler1D] = [];      array2D[zaehler1D] = array1D[zaehler1D].split(columnSeparator);    }    array1D = null;    return array2D;  }}function twoDArrayToString(twoDArray, columnSeparator, rowSeparator){  var tempResult = "";  for (r=0;r<=twoDArray.length-1;r++){    tempResult += twoDArray[r].join(columnSeparator) + rowSeparator;  }  tempResult = tempResult.substring(0, (tempResult.length - rowSeparator.length));  return tempResult;}function addNewPage(){  var tempPage = app.activeDocument.pages.add(LocationOptions.AT_END);  app.activeWindow.activePage = tempPage;  return tempPage;}function moveObjectToPage(frameObject, pageObject){  var tempBounds = frameObject.geometricBounds;  app.activeDocument.viewPreferences.rulerOrigin = RulerOrigin.PAGE_ORIGIN;//ARGHH!  frameObject.move (pageObject);  frameObject.geometricBounds = tempBounds;  return frameObject;}function setPageSize(xWidth, yHeight){  app.activeDocument.documentPreferences.pageWidth = xWidth;  app.activeDocument.documentPreferences.pageHeight = yHeight;  return true;}function placeSnippet(snippetPath, xSnippet, ySnippet){  var tempSnippetPath = new File(snippetPath);  var tempSnippet = app.activeWindow.activePage.place(tempSnippetPath,[xSnippet, ySnippet]);  return tempSnippet;}function placeAssetFromLibrary(assetName, xAsset, yAsset){    // to do...    /*    myLibrary = app.libraries[0];    for(i=0; i<myLibrary.assets.length;i++){        alert(myLibrary.assets[i].name);        if(myLibrary.assets[i].name == assetName){            alert("bingo! Placing this asset: " + assetName);        }    }    */}function searchReplaceTextframe(textframeObject, searchText, replaceText){  app.findTextPreferences = NothingEnum.nothing;  app.changeTextPreferences = NothingEnum.nothing;  app.findTextPreferences.findWhat = searchText;  app.changeTextPreferences.changeTo = replaceText;  textframeObject.parentStory.changeText();  return textframeObject;}function resetCharacterStyle(textObject) {  var tempNoneStyleName = "---basedOnNoneStyle---";  try{      app.activeDocument.characterStyles.item(tempNoneStyleName).remove();    }catch(e){      // $.writeln("cannot app.activeDocument.characterStyles.item(tempNoneStyleName).remove(): " + e);      //alert(e);    }      var noneStyle = app.activeDocument.characterStyles.item(0);  var basedOnNone = app.activeDocument.characterStyles.add({name: tempNoneStyleName, basedOn:noneStyle});  textObject.applyCharacterStyle(basedOnNone);  basedOnNone.remove(noneStyle);  return textObject;}function fitTextboxHeightToContent(frameObject){  var tempBounds = frameObject.geometricBounds;  while (!frameObject.overflows){     tempBounds[2] -= 1;     frameObject.geometricBounds = tempBounds;    if(tempBounds[2]*1<1){      break;    }  }  while (frameObject.overflows){     tempBounds[2] += 1;     frameObject.geometricBounds = tempBounds;   }  tempBounds[2] += 3;   frameObject.geometricBounds = tempBounds;  return frameObject;}function fitTextboxHeightAndThread(frameObject, xNextFrame, yNextFrame, wNextFrame, hNextFrame){  // use last thread of threaded textframe  // if not threaded textframe itself will be used  frameObject = frameObject.endTextFrame;  var tempBounds = frameObject.geometricBounds;  var tempPage = frameObject.parent.pages[0];  while (!frameObject.overflows){     tempBounds[2] -= 1;     frameObject.geometricBounds = tempBounds;    if(tempBounds[2]*1<1){      break;    }  }  while (frameObject.overflows){    tempBounds[2] += 1;     frameObject.geometricBounds = tempBounds;  }  tempBounds[2] += 3;  frameObject.geometricBounds = tempBounds;  // if frameObject bottom hits page bottom margin or is already over it  if(tempBounds[2] >= tempPage.bounds[2] - tempPage.marginPreferences.bottom){    // reset bottom margin to max allowed size    tempBounds[2] = tempPage.bounds[2] - tempPage.marginPreferences.bottom;    frameObject.geometricBounds = tempBounds;    try{      // proceed on new after current page      var tempPage = app.activeDocument.pages.add(LocationOptions.AFTER, tempPage);      app.activeWindow.activePage = tempPage;      // add a new text frame there      var tempNextTextframe = addFrame(0, 0, 1, 1, "");      // connect old and new text frame      frameObject.nextTextFrame = tempNextTextframe;      // resize nextTextFrame      tempNextTextframe = modifyFrame(tempNextTextframe, xNextFrame, yNextFrame, wNextFrame, hNextFrame);      // try if nextTextFrame needs to be resized; use same resizing values as before      fitTextboxHeightAndThread(frameObject.nextTextFrame, xNextFrame, yNextFrame, wNextFrame, hNextFrame);    }catch(e){      return false;    }  }  return frameObject;}function httpGetBinaryFile(httpSourceFileURL, httpSourcePort, targetFolder){  if(httpSourceFileURL.indexOf("://")<0){    // exit if there's no protocol given    return false;  }  var urlWithoutProtocol = httpSourceFileURL.substr(httpSourceFileURL.indexOf("://")+3);  var targetFilename = urlWithoutProtocol.substring(urlWithoutProtocol.lastIndexOf('/')+1);  var httpSourceHost = urlWithoutProtocol.substr(0, urlWithoutProtocol.indexOf("/"));  var httpSourcePath = urlWithoutProtocol.substr(urlWithoutProtocol.indexOf("/")+1);  // binary file download  var httpConnection = new Socket;  httpConnection.timeout = 6000;  if(httpConnection.open (httpSourceHost + ":" + httpSourcePort, "BINARY")){    httpConnection.write("GET http://" + httpSourceHost + "/" + httpSourcePath + " HTTP/1.0\n\n");    var httpBinaryReply = httpConnection.read(99999999999);    httpConnection.close();    httpBinaryReply = removeHeaders(httpBinaryReply);    var tempTargetFile = File(targetFolder + "/" + targetFilename);    tempTargetFile.encoding = "BINARY";    tempTargetFile.open("w");    tempTargetFile.write(httpBinaryReply);    tempTargetFile.close();    return tempTargetFile;  }else{    // exit if connection is not possible    return false;  }  // internal helper functions  // Remove header lines from HTTP response    function removeHeaders(binaryWithHeader){    var endFlag = true;    var tempLine = "";    var nFirst = 0;    var count  = 0;    while(endFlag){      // iterate over header lines      tempLine = iterateHeaderLines(binaryWithHeader);      endFlag = tempLine.length >= 2;      nFirst = tempLine.length + 1;      binaryWithHeader = binaryWithHeader.substr(nFirst);    }    return binaryWithHeader;  }  // get single response line from header  function iterateHeaderLines(headerLine){    var tempLine = "";    // computing line end char 10 \n    for (var i = 0; headerLine.charCodeAt(i) != 10; i++){      tempLine += headerLine[i];    }    return tempLine;  }}function modifyFrame(frameObject, xFrame, yFrame, wFrame, hFrame){  var tempXFrame = xFrame;  var tempYFrame = yFrame;  var tempWFrame = wFrame + xFrame;  var tempHFrame = hFrame + yFrame;  frameObject.geometricBounds = [tempYFrame, tempXFrame, tempHFrame, tempWFrame];  return frameObject;}function csvToTwoDArray(csvString, splittingOptions) {    // heavily inspired by    // (c)2012-2013 Daniel Tillin    // http://code.google.com/p/csv-to-array/     var od = {        'fSep': ',',        'rSep': '\r\n',        'quot': '"',        'head': false,        'trim': false    }    if (splittingOptions) {        for (var i in od) {            if (!splittingOptions[i]) splittingOptions[i] = od[i];        }    } else {        splittingOptions = od;    }    var a = [        ['']    ];    for (var r = f = p = q = 0; p < csvString.length; p++) {        switch (c = csvString.charAt(p)) {        case splittingOptions.quot:            if (q && csvString.charAt(p + 1) == splittingOptions.quot) {                a[r][f] += splittingOptions.quot;                ++p;            } else {                q ^= 1;            }            break;        case splittingOptions.fSep:            if (!q) {                if (splittingOptions.trim) {                    a[r][f] = a[r][f].replace(/^\s\s*/, '').replace(/\s\s*$/, '');                }                a[r][++f] = '';            } else {                a[r][f] += c;            }            break;        case splittingOptions.rSep.charAt(0):            if (!q && (!splittingOptions.rSep.charAt(1) || (splittingOptions.rSep.charAt(1) && splittingOptions.rSep.charAt(1) == csvString.charAt(p + 1)))) {                if (splittingOptions.trim) {                    a[r][f] = a[r][f].replace(/^\s\s*/, '').replace(/\s\s*$/, '');                }                a[++r] = [''];                a[r][f = 0] = '';                if (splittingOptions.rSep.charAt(1)) {                    ++p;                }            } else {                a[r][f] += c;            }            break;        default:            a[r][f] += c;        }    }    if (splittingOptions.head) {        a.shift()    }    if (a[a.length - 1].length < a[0].length) {        a.pop()    }    return a;}function readFile(fullFilePath){    var fileIn = File(fullFilePath);    fileIn.open("r");    if(fileIn.exists ){        var fileContent = fileIn.read();        fileIn.close();        return(fileContent.toString());    }else{        return false;    }}function writeFile(fullFilePath, fileContent, lineEnding){    var fileOut = File(fullFilePath);    fileOut.open("w");    if(fileOut.exists){        fileOut.encoding = "UTF-8";        if(!lineEnding || lineEnding!='Unix' && lineEnding!='Windows' && lineEnding!='Macintosh'){            lineEnding = 'Unix';// 'Windows' or 'Macintosh'        }        fileOut.lineFeed = lineEnding;        fileOut.write(fileContent);        fileOut.close();        return true;    }else{        return false;    }}